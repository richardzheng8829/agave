# aTokens

aTokens are yield-generating tokens that are minted and burned upon [`deposit`](../lendingpool/#deposit) and [`withdraw`](../lendingpool/#withdraw). The aTokens' value is pegged to the value of the corresponding deposited asset at a 1:1 ratio, and can be safely stored, transferred or traded. All interest collected by the aTokens reserves are distributed to aTokens holders directly by continuously increasing their wallet balance.&#x20;

The source code can be found [on Github here](https://github.com/aave/protocol-v2/blob/ice/mainnet-deployment-03-12-2020/contracts/protocol/tokenization/AToken.sol).

{% hint style="warning" %}
For all minting and burning actions, see [`Deposit()`](../lendingpool/#deposit) and [`Withdraw()`](../lendingpool/#withdraw) methods in the `LendingPool` contract.
{% endhint %}

## EIP20 Methods

All standard EIP20 methods are implemented, such as `balanceOf()`, `transfer()`, `transferFrom()`, `approve()`, `totalSupply()`, etc.

{% hint style="info" %}
`balanceOf()` will always return the most up to date balance of the user, which includes their principal balance + the interest generated by the principal balance.
{% endhint %}

## EIP2612 Methods

### permit()

**`function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)`**

Allows a user to permit another account (or contract) to use their funds using a signed message. This enables gas-less transactions and single approval/transfer transactions.

| Parameter  | Type    | Description                                                                            |
| ---------- | ------- | -------------------------------------------------------------------------------------- |
| `owner`    | address | The owner of the funds                                                                 |
| `spender`  | address | The spender for the funds                                                              |
| `value`    | uint256 | The amount the `spender` is permitted to use                                           |
| `deadline` | uint256 | The deadline timestamp that the permit is valid. Use `type(uint).max` for no deadline. |
| `v`        | uint8   | Signature parameter                                                                    |
| `r`        | bytes32 | Signature parameter                                                                    |
| `s`        | bytes32 | Signature parameter                                                                    |

{% tabs %}
{% tab title="Web3.js" %}
```javascript
import { signTypedData_v4 } from 'eth-sig-util'
import { fromRpcSig } from 'ethereumjs-util'

// ... other imports

import aTokenAbi from "./aTokenAbi.json"

// ... setup your web3 provider

const aTokenAddress = "ATOKEN_ADDRESS"
const aTokenContract = new web3.eth.Contract(aTokenAbi, aTokenAddress)

const privateKey = "YOUR_PRIVATE_KEY_WITHOUT_0x"
const chainId = 1
const owner = "OWNER_ADDRESS"
const spender = "SPENDER_ADDRESS"
const value = 100 // Amount the spender is permitted
const nonce = 1 // The next valid nonce, use `_nonces()`
const deadline = 1600093162

const permitParams = {
  types: {
    EIP712Domain: [
      { name: "name", type: "string" },
      { name: "version", type: "string" },
      { name: "chainId", type: "uint256" },
      { name: "verifyingContract", type: "address" },
    ],
    Permit: [
      { name: "owner", type: "address" },
      { name: "spender", type: "address" },
      { name: "value", type: "uint256" },
      { name: "nonce", type: "uint256" },
      { name: "deadline", type: "uint256" },
    ],
  },
  primaryType: "Permit",
  domain: {
    name: "aTOKEN_NAME",
    version: "1",
    chainId: chainId,
    verifyingContract: aTokenAddress,
  },
  message: {
    owner,
    spender,
    value,
    nonce,
    deadline,
  },
}

const signature = signTypedData_v4(
  Buffer.from(privateKey, "hex"),
  { data: permitParams }
)

// The signature can now be used to execute the transaction

const { v, r, s } = fromRpcSig(signature)

await aTokenContract.methods
    .permit({
      owner,
      spender,
      value,
      deadline,
      v,
      r,
      s
    })
    .send()
    .catch((e) => {
        throw Error(`Error permitting: ${e.message}`)
    })
```
{% endtab %}
{% endtabs %}

### \_nonces()

**`function _nonces(address owner) public`**

Returns the next valid nonce to submit when calling `permit()`

## Methods

### UNDERLYING\_ASSET\_ADDRESS()

**`function UNDERLYING_ASSET_ADDRESS()`**

Returns the underlying asset of the aToken.

### RESERVE\_TREASURY\_ADDRESS()

**`function RESERVE_TREASURY_ADDRESS()`**

Returns the address of the aTokens reserve treasury.

### POOL()

**`function POOL()`**

Returns the address of the associated [`LendingPool`](../lendingpool/) for the aToken.

### scaledBalanceOf**()**

**`function scaledBalanceOf(address user)`**

Returns the scaled balance of `user` as a `uint256`.

The scaled balance is the balance of the underlying asset of the user (amount deposited), divided by the current liquidity index at the moment of the update.&#x20;

I.e. $$scaledBalance = amount Deposited / currentLiquidityIndex$$&#x20;

This essentially 'marks' when a user has deposited in the reserve pool, and can be used to calculate the users current compounded aToken balance.

Example:

* User A deposits 1000 DAI at the liquidity index of 1.1
* User B deposits another amount into the same pool
* The liquidity index is now 1.2.
* Therefore to calculate User A's current compounded aToken balance, the reverse operation should be performed: $$aTokenBalance = scaledBalance * currentLiquidityIndex$$&#x20;

### getScaledUserBalanceAndSupply**()**

**`function getScaledUserBalanceAndSupply(address user)`**

Returns the scaled balance of `user`and the principal total supply.

#### Return values

| Type    | Description            |
| ------- | ---------------------- |
| uint256 | scaled balance of user |
| uint256 | principal total supply |

### scaledTotalSupply**()**

**`function scaledTotalSupply()`**

Returns the scaled total supply of the aToken as `uint256`.

The scaled total supply is the sum of all the updated stored balances, divided by the reserve index at the moment of the update.

**`function isTransferAllowed(address user, uint256 amount)`**

Returns `true` if a transfer is allowed.

Specifically, a transfer will fail if the resulting Health Factor of `user`  will end up being below 1.

